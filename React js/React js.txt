1. Your React app suddenly becomes slow after adding new features. How do you find and fix the issue?
‚úÖ How to Debug

Chrome DevTools ‚Äì Performance Tab

Record performance to find long tasks, slow renders, memory leaks.

React DevTools ‚Äì Profiler

Detect unnecessary re-renders and components causing slowdowns.

Avoid Unnecessary Re-Renders

Use:

React.memo

useMemo

useCallback

Virtualization for Large Lists

Use react-window or react-virtualized to render only visible items.

Avoid Inline Functions & Objects

Inline props cause re-creation on every render, triggering child re-renders.

‚úÖ Real-world Example

An e-commerce app showing 10,000 products without virtualization will lag. With virtualization, only visible items render ‚Üí smooth performance.

‚úÖ 2. How do you prevent the login page from being accessible after the user is logged in?
‚úÖ Solution

Use Protected Routes

Restrict routes based on authentication status.

Maintain Global Auth State

Keep isAuthenticated flag using:

Context API or

Redux

Conditional Routing

{isAuthenticated ? <Dashboard /> : <Navigate to="/login" />}


Redirect After Login

If already logged in ‚Üí redirect user to dashboard.

‚úÖ Real-world Example

Banking apps never allow access to the login page after login unless you log out.

‚úÖ 3. How do you handle API errors gracefully in the UI?
‚úÖ Best Practices

Use try‚Äìcatch or .catch()

Show User-Friendly Messages

Example:
‚û§ ‚ÄúSomething went wrong. Please try again.‚Äù

Use Toast Notifications

Show error/success messages non-intrusively.

Show Fallback UI

Error screen, retry button, skeleton loader.

Retry Mechanism

Allow user to retry failed requests.

Use Error Boundaries

Catch rendering errors at component level.

Categorize Errors

Network error

Server error

Unauthorized (401)

Forbidden (403)

‚úÖ Real-world Example

Food delivery app says
‚ÄúRestaurant is currently unavailable‚Äù instead of showing a blank screen or error stack.

‚úÖ 4. A component is fetching the same data multiple times unnecessarily. How would you fix it?
‚úÖ Solutions

Use React Query / TanStack Query

Built-in caching and background refetching.

Store Data in Global State

Use Context API or Redux to avoid duplicate fetching.

Use useMemo for Derived Data

Prevent expensive recalculations.

Conditional Fetching

if (!data) fetchData();

‚úÖ Real-world Example

On a dashboard, if 5 charts fetch the same user profile, fetch once globally and reuse it.

‚úÖ 5. How do you optimize bundle size in a large React app?
‚úÖ Optimization Techniques

Code Splitting

const Dashboard = React.lazy(() => import("./Dashboard"));


Tree Shaking

Remove unused code via Webpack / Vite.

Dynamic Imports

import("chart-library").then(...)


Asset Optimization

Compress images, fonts, videos.

Caching Static Files

Use browser cache, CDN, service workers.

Remove Unused Dependencies





Step 1: Detect Unnecessary Re-renders

Use React DevTools ‚Üí Profiler.

‚úÖ Step 2: Fix with React.memo
const ProductCard = React.memo(({ product }) => {
  console.log("Rendered");
  return <div>{product.name}</div>;
});

‚úÖ Step 3: Fix Expensive Calculations using useMemo
const totalPrice = useMemo(() => {
  return cart.reduce((sum, item) => sum + item.price, 0);
}, [cart]);

‚úÖ Step 4: Avoid Inline Functions using useCallback
const handleClick = useCallback(() => {
  setCount(prev => prev + 1);
}, []);

‚úÖ Step 5: Virtualization for Large Lists
import { FixedSizeList as List } from "react-window";

<List
  height={500}
  itemCount={10000}
  itemSize={35}
  width={300}
>
  {({ index, style }) => <div style={style}>Item {index}</div>}
</List>


‚úÖ Result: Only visible rows render ‚Üí Massive performance boost.

‚úÖ 2. Prevent Login Page After User is Logged In (Protected Routes)
‚úÖ Auth Context
export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [isAuth, setIsAuth] = useState(false);

  return (
    <AuthContext.Provider value={{ isAuth, setIsAuth }}>
      {children}
    </AuthContext.Provider>
  );
};

‚úÖ Protected Route
const ProtectedRoute = ({ children }) => {
  const { isAuth } = useContext(AuthContext);
  return isAuth ? children : <Navigate to="/login" />;
};

‚úÖ Route Setup
<Route path="/dashboard"
  element={
    <ProtectedRoute>
      <Dashboard />
    </ProtectedRoute>
  }
/>

‚úÖ Redirect Logged-in Users from Login
if (isAuth) return <Navigate to="/dashboard" />;


‚úÖ Used in Banking, E-commerce, SaaS Apps

‚úÖ 3. Handling API Errors Gracefully in React UI
‚úÖ API Call with Try‚ÄìCatch
const fetchData = async () => {
  try {
    const res = await fetch("/api/user");
    if (!res.ok) throw new Error("Failed to fetch");
    const data = await res.json();
    setUser(data);
  } catch (err) {
    setError(err.message);
  }
};

‚úÖ Show Toast Error
{error && <Toast message="Something went wrong!" />}

‚úÖ Retry Button
<button onClick={fetchData}>Retry</button>

‚úÖ Error Boundary
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      return <h2>Something went wrong.</h2>;
    }
    return this.props.children;
  }
}


‚úÖ Why this matters: Prevents white screen of death in production.

‚úÖ 4. Prevent Multiple API Calls for Same Data
‚úÖ Using React Query (BEST PRACTICE)
const { data, isLoading } = useQuery(
  ["users"],
  fetchUsers,
  { staleTime: 60000 }
);

‚úÖ Using Context Cache
if (!users.length) fetchUsers();

‚úÖ Using Redux

Store API result once ‚Üí reuse everywhere.

‚úÖ Avoid Re-fetch with useEffect
useEffect(() => {
  fetchData();
}, []); // ‚úÖ avoids multiple calls


‚úÖ Real-world: Dashboards, Notifications, Profile APIs.

‚úÖ 5. Optimizing Bundle Size in Large React App
‚úÖ Code Splitting with Lazy + Suspense
const Dashboard = React.lazy(() => import("./Dashboard"));

<Suspense fallback={<Loader />}>
  <Dashboard />
</Suspense>

‚úÖ Dynamic Imports
import("chart.js").then(chart => {
  chart.render();
});

‚úÖ Tree Shaking (Webpack/Vite default)
import { debounce } from "lodash"; // ‚ùå BAD
import debounce from "lodash/debounce"; // ‚úÖ GOOD













HTML & CSS INTERVIEW QUESTIONS (Extracted + Answers)
1. What new tags were introduced in HTML5?

Answer:
HTML5 introduced semantic tags such as:
<header>, <footer>, <nav>, <section>, <article>, <figure>, <figcaption>, <main>, <aside>, <video>, <audio>, <canvas>, <picture>.

These improve SEO, accessibility, and code readability.

2. What are Semantic Tags and why are they important?

Answer:
Semantic tags clearly describe the purpose of content.
They help:

Search engines understand page structure

Improve SEO

Improve screen-reader accessibility

Make code more readable

3. Difference between ID and Class

Answer:

ID	Class
Unique	Can be reused
Higher priority	Lower priority
Used once	Used multiple times
#id selector	.class selector

‚úÖ Prefer class for styling, id for unique JS access.

4. Difference between Inline, Block, and Inline-Block

Answer:

Inline: No new line, no width/height (e.g. span)

Block: Takes full width, starts new line (e.g. div, p)

Inline-block: Inline + supports width & height

5. Difference between Relative, Absolute, Fixed, Sticky

Answer:

Relative: Moves relative to itself

Absolute: Relative to nearest positioned parent

Fixed: Relative to viewport, never moves

Sticky: Acts relative first, then fixed after scroll threshold

6. Difference between LocalStorage, SessionStorage & Cookies

Answer:

Storage	Persistence	Server Access	Size
LocalStorage	Permanent	No	~5MB
SessionStorage	Until tab close	No	~5MB
Cookies	Configurable	Yes	~4KB

‚úÖ Banking apps use Cookies (HTTP-Only, Secure) for tokens.

7. Difference between visibility: hidden and display: none

Answer:

visibility: hidden ‚Üí Element invisible but space remains

display: none ‚Üí Element removed completely from layout

8. Pseudo-class vs Pseudo-element

Answer:

Pseudo-class: :hover, :focus, :active

Pseudo-element: ::before, ::after

‚úÖ JAVASCRIPT INTERVIEW QUESTIONS
9. Difference between var, let, const
Feature	var	let	const
Scope	Function	Block	Block
Redeclare	Yes	No	No
Reassign	Yes	Yes	No
Hoisting	Yes (undefined)	TDZ	TDZ
10. What is Closure?

Answer:
A closure is when a function remembers variables from its parent scope even after execution.

function outer() {
  let x = 10;
  return function inner() {
    console.log(x);
  }
}

11. Find the Second Highest Number in an Array
function secondLargest(arr){
 let first = -Infinity, second = -Infinity;

 for(let num of arr){
   if(num > first){
     second = first;
     first = num;
   } else if(num > second && num !== first){
     second = num;
   }
 }
 return second;
}

12. How to Reverse a String Without Built-in Function
let str = "hello";
let result = "";

for(let i = str.length - 1; i >= 0; i--){
  result += str[i];
}
console.log(result);

13. Output Question with += on innerHTML
p.innerHTML += " world";


‚úÖ Output: "hello world"

14. Why Setting State Inside Render Causes Infinite Loop?

Answer:
Because:

Render ‚Üí setState ‚Üí Re-render ‚Üí setState ‚Üí infinite cycle

‚úÖ State updates should be inside useEffect or event handlers.

‚úÖ REACT INTERVIEW QUESTIONS
15. Difference between Functional and Class Components
Functional	Class
Uses Hooks	Uses lifecycle
Simpler	More boilerplate
Better Performance	Older approach
Easy testing	Harder testing
16. Why Industry Shifted from Class to Functional Components?

Answer:

Hooks provide lifecycle control

Better readability

Easier reusability

Better performance

Simpler testing

17. What are React Hooks and Why Introduced?

Answer:
Hooks allow using state, lifecycle, and side-effects in functional components.
They improve:

Code reuse

Cleanup

Readability

Composition

18. Write a Custom Hook for API Fetching
function useFetch(url){
 const [data, setData] = useState(null);
 const [loading, setLoading] = useState(true);
 const [error, setError] = useState(null);

 useEffect(()=>{
  fetch(url)
   .then(res => res.json())
   .then(setData)
   .catch(setError)
   .finally(()=>setLoading(false));
 }, [url]);

 return { data, loading, error };
}

19. Difference between useEffect and useLayoutEffect
useEffect	useLayoutEffect
After paint	Before paint
Async	Sync
No UI blocking	Blocks UI
For API calls	For layout/animation fixes
20. Controlled vs Uncontrolled Components

Controlled: State controlled by React

Uncontrolled: State controlled by DOM using ref

21. What is Redux?

Answer:
Redux is a global state management library used to:

Avoid prop drilling

Manage complex shared state

Centralize application data

22. Redux Architecture

Flow:

Component ‚Üí Action ‚Üí Reducer ‚Üí Store ‚Üí Component

23. Which Part of Redux is Pure?

‚úÖ Reducer is a Pure Function

24. What is React Router 7 Major Change?

‚úÖ react-router-dom is merged into react-router

25. How to Improve Performance with Large API Data

Answer:

Virtualization (react-window)

Pagination

Memoization

Caching

26. How Do You Optimize React Applications?

Code splitting (React.lazy)

useMemo & useCallback

Remove unnecessary states

Use React Query instead of manual state

Bundle optimization

Asset compression

27. How Do You Deploy React Apps?

Answer:

GitHub Actions CI/CD

Automated build

Deploy on Render/Vercel

Monorepo pipeline

28. Have You Used Unit Testing?

‚úÖ Basic exposure to Jest (not daily usage)













1. How to optimize large Redux datasets (10,000+ records)?
‚úÖ Best Practices

Never store huge datasets at once

Use server-side pagination or cursor-based pagination.

Normalize Redux State

{
  users: { byId: {}, allIds: [] }
}


Prevents duplication and improves lookup speed.

Use Selectors with Memoization

import { createSelector } from '@reduxjs/toolkit';


Avoids unnecessary recalculations.

Virtualize Rendering

Use react-window / react-virtualized

Render only visible rows.

Avoid Deeply Nested State

Flat structure = faster updates.

Use Redux Toolkit

Faster, less boilerplate, better performance.

‚úÖ Interview One-Line:

‚ÄúI optimize large Redux datasets using server-side pagination, normalized state, memoized selectors, and list virtualization.‚Äù

‚úÖ 2. How to handle slow APIs in the UI? (5‚Äì10 sec delay)
‚úÖ UI/UX Improvements

Skeleton Loaders / Shimmer

Central Loader

Optimistic UI (if applicable)

React Query / Caching

Lazy Loading Components

Timeout + Retry Button

Network Error Handling

‚úÖ Example
const { data, isLoading } = useQuery("users", fetchUsers);

‚úÖ Interview One-Line:

‚ÄúFor slow APIs, I use loaders, skeleton UI, caching, background refetch, and retry mechanisms for better UX.‚Äù

‚úÖ 3. How to secure JWT authentication in React?
‚úÖ Best Security Practices

Store Access Token in HTTP-Only Secure Cookie

Use Refresh Token Flow

Short Expiry for Access Token

Enable CORS, SameSite, Secure Flags

Never store JWT in localStorage for banking apps

Validate token on every API call using middleware

‚úÖ Token Flow
Login ‚Üí Access Token (short)
      ‚Üí Refresh Token (long)

‚úÖ Interview One-Line:

‚ÄúI secure JWT using HTTP-only cookies, refresh tokens, short expiry, and server-side validation middleware.‚Äù

‚úÖ 4. How to avoid dashboard re-rendering with multiple charts & filters?
‚úÖ Optimization Techniques

Fetch API at Parent Only

Pass Data via Props

Use React.memo() for Charts

Use useMemo for Computed Data

Use useCallback for Filter Handlers

Avoid Inline Objects & Functions

Single Global Loader

‚úÖ Example
const Chart = React.memo(({ data }) => { ... });

‚úÖ Interview One-Line:

‚ÄúI prevent dashboard re-renders by lifting data to parent, memoizing charts, and caching handlers and computed values.‚Äù

‚úÖ 5. How SSR improves SEO?
‚úÖ CSR vs SSR
CSR (CRA)	SSR (Next.js)
Empty HTML on load	Fully rendered HTML
Google waits for JS	Google crawls instantly
Poor SEO	Excellent SEO
Slower first paint	Faster first paint
‚úÖ SSR Benefits

Better Google indexing

Faster First Contentful Paint (FCP)

Social media preview works

Better Lighthouse score

‚úÖ Interview One-Line:

‚ÄúSSR improves SEO because search engines receive fully rendered HTML instead of an empty JavaScript shell.‚Äù

‚úÖ 6. Why use Next.js instead of CRA?
‚úÖ Key Advantages of Next.js

Built-in SSR & SSG

File-based routing

API routes (Backend + Frontend)

Automatic code splitting

Image optimization

SEO-friendly out of the box

Better performance

‚úÖ CRA Limitations

Client-Side Rendering only

Poor SEO

Manual optimization required

‚úÖ Interview One-Line:

‚ÄúNext.js gives built-in SEO, SSR, API routes, and production-level performance which CRA lacks.‚Äù

‚úÖ 7. How debouncing improves search performance?
‚úÖ Without Debounce

API called on every keystroke

Server overload

Poor UX

‚úÖ With Debounce

API is called only after user stops typing

‚úÖ Working Logic
setTimeout(() => callAPI(value), 500);

‚úÖ Benefits

Fewer API calls

Better performance

Saves server cost

Smooth UX

‚úÖ Interview One-Line:

‚ÄúDebouncing prevents unnecessary API calls by waiting until the user stops typing before firing the request.‚Äù

‚úÖ 8. How virtualization improves table performance?
‚úÖ Problem Without Virtualization

10,000+ DOM nodes

High memory usage

Page lag & crashes

‚úÖ With Virtualization

Only visible rows are rendered

DOM size is minimal

Smooth scrolling

‚úÖ Tools

react-window

react-virtualized

‚úÖ Example Use Case

Large logs table

CRM transactions

Stock market dashboards

‚úÖ Interview One-Line:

‚ÄúVirtualization boosts performance by rendering only visible rows instead of the entire dataset.‚Äù
















1. Difference Between Block-Level and Inline Elements

Answer:

Block elements: Take full width and start on a new line
Examples: div, p, section

Inline elements: Take only required width
Examples: span, a, strong

2. What are Semantic HTML Tags?

Answer:
Semantic tags clearly describe the meaning of their content.
Examples:
header, footer, nav, article, section, main, aside

3. Why Use Semantic Tags Instead of div?

Answer:

Better SEO ranking

Better accessibility

Clear document structure

Easier for screen readers & search engine crawlers

4. Difference Between Absolute and Fixed Position

Answer:

absolute ‚Üí Positioned relative to nearest positioned parent

fixed ‚Üí Positioned relative to viewport and stays fixed on scroll

5. Difference Between px, %, and em
Unit	Meaning
px	Fixed size
%	Relative to parent
em	Relative to parent font size
6. How to Make a Website Mobile Friendly?

Answer:

Media queries

Flexbox & Grid

Relative units (%, em, rem)

Responsive images

7. Difference Between CSS Grid and Flexbox

Answer:

Flexbox ‚Üí 1D layout (row or column)

CSS Grid ‚Üí 2D layout (row + column)

8. How to Make Images Responsive
img {
  max-width: 100%;
  height: auto;
}

9. Difference Between LocalStorage, SessionStorage, and Cookies
Feature	LocalStorage	SessionStorage	Cookies
Lifetime	Until deleted	Until tab close	Expiry-based
Size	~5 MB	~5 MB	~4 KB
Server Access	No	No	Yes

‚úÖ Cookies are preferred for authentication.

‚úÖ JAVASCRIPT ‚Äì Extracted Interview Questions with Correct Answers
10. Difference Between var, let, and const
Feature	var	let	const
Scope	Function	Block	Block
Reassign	Yes	Yes	No
Redeclare	Yes	No	No
Hoisting	Yes (undefined)	TDZ	TDZ
11. What is Hoisting?

Answer:
JavaScript moves variable & function declarations to the top of the scope before execution.

12. What is Event Delegation and Why Is It Used?

Answer:
Event delegation is attaching one event listener to a parent instead of many children using event.target.

‚úÖ Improves performance
‚úÖ Handles dynamically added elements

13. Difference Between == and ===

== ‚Üí compares value only

=== ‚Üí compares value + type

14. Why [] === [] is false?

Because arrays are compared by reference, not by value.

15. Difference Between Debouncing and Throttling
Debouncing	Throttling
Executes after delay	Executes at fixed interval
Used in search	Used in scroll
16. Floating Point Issue: 0.1 + 0.2 === 0.3

‚úÖ Output: false
Because of floating-point precision error.

17. Object Reference Example
let obj = { a: 1 };
let copy = obj;
copy.a = 5;
console.log(obj.a); // 5


‚úÖ Because object is copied by reference, not value.

18. Reverse a String Without reverse()
function reverseStr(str) {
  let res = "";
  for (let i = str.length - 1; i >= 0; i--) {
    res += str[i];
  }
  return res;
}

19. Remove Duplicate Values from Array
function removeDuplicates(arr) {
  let result = [];
  for (let i of arr) {
    if (!result.includes(i)) result.push(i);
  }
  return result;
}

‚úÖ REACT ‚Äì Extracted Interview Questions with Correct Answers
20. Difference Between Functional and Class Components
Functional	Class
Uses Hooks	Uses Lifecycle
Less code	More boilerplate
Easier testing	Harder testing
21. What is Virtual DOM?

Answer:
Virtual DOM is a lightweight copy of the real DOM used to optimize performance by updating only changed elements.

22. What is Reconciliation?

Answer:
Reconciliation is React‚Äôs process of comparing old and new Virtual DOM and updating only the changed nodes in the real DOM.

23. Difference Between Controlled and Uncontrolled Components

Controlled ‚Üí State managed by React using useState

Uncontrolled ‚Üí State managed by DOM using useRef

24. Why Do We Use useState and useEffect?

useState ‚Üí Manages component state

useEffect ‚Üí Handles side effects like API calls, subscriptions

25. Relation Between useEffect and Class Lifecycle Methods
useEffect	Class Lifecycle
Empty deps	componentDidMount
With deps	componentDidUpdate
Cleanup	componentWillUnmount
26. Other Ways to Manage State

useReducer

Context API

Redux / Redux Toolkit

27. Redux Toolkit vs Redux

Redux Toolkit:

Less boilerplate

Faster development

Official recommended approach

28. How Context API Works

Answer:
Context allows passing global data without prop drilling using:

createContext

Provider

useContext

29. How to Optimize React App Performance

Answer:

Lazy loading

Code splitting

useMemo, useCallback

CDN for assets

Virtual DOM optimization

30. Difference Between useMemo and useCallback

useMemo ‚Üí Memorizes values

useCallback ‚Üí Memorizes functions

31. If API Takes 5 Seconds, How Do You Improve UX?

Answer:

Loader

Skeleton UI

Retry option

Background fetch

Pagination & caching

32. How to Handle 10,000+ Rows in Dashboard

Answer:

Pagination

Virtualization

Infinite scrolling

Server-side filtering




1. Difference Between var, let, and const
Feature	var	let	const
Scope	Function / Global	Block	Block
Re-declare	‚úÖ Yes	‚ùå No	‚ùå No
Re-assign	‚úÖ Yes	‚úÖ Yes	‚ùå No
Hoisting	‚úÖ Yes (undefined)	‚úÖ TDZ	‚úÖ TDZ

‚úÖ let and const are block-scoped
‚úÖ var is function-scoped
‚úÖ const must be initialized at declaration

2. What is Hoisting?

Answer:
Hoisting is JavaScript‚Äôs behavior of moving variable and function declarations to the top of their scope before execution.

Example:
console.log(a); // undefined
var a = 5;

3. Difference Between Arrow Function and Normal Function
Feature	Normal Function	Arrow Function
Syntax	Longer	Shorter
this	Dynamic	Lexical
Constructor	‚úÖ Yes	‚ùå No
arguments object	‚úÖ Yes	‚ùå No

‚úÖ Arrow functions don‚Äôt have their own this.

4. Difference Between == and ===

== ‚Üí Compares value only

=== ‚Üí Compares value + type

2 == "2"   // true
2 === "2"  // false

5. What is Closure?

Answer:
A closure gives access to an outer function‚Äôs variables even after the outer function has finished execution.

Example:
function outer() {
  let count = 0;
  return function() {
    return count++;
  };
}

const counter = outer();
counter(); // 0
counter(); // 1

6. What is a Pure Function?

Answer:
A pure function:

Always returns the same output for the same input

Has no side effects

function add(a, b) {
  return a + b;
}

7. What is the Event Loop?

Answer:
The event loop continuously:

Checks if the call stack is empty

Moves tasks from:

Callback Queue

Microtask Queue
into the call stack for execution.

‚úÖ Enables non-blocking asynchronous execution

8. Difference Between Async/Await and Promises
Promises	Async/Await
Uses .then() & .catch()	Uses await
Less readable	More readable
Callback-style	Synchronous-looking
9. Difference Between map, filter, and reduce
Method	Returns	Purpose
map	New array	Transform data
filter	New array	Filter data
reduce	Single value	Aggregate data
10. map() Example
const arr = [1, 2, 3];
const doubled = arr.map(n => n * 2);

11. filter() Example
const even = arr.filter(n => n % 2 === 0);

‚úÖ REACT INTERVIEW QUESTIONS (Extracted & Polished)
12. Difference Between Functional and Class Components
Functional	Class
Uses Hooks	Uses Lifecycle
No render()	Needs render()
Less boilerplate	More boilerplate
Preferred now	Legacy use
13. What are React Hooks?

Answer:
Hooks allow state, lifecycle, and side-effect handling in functional components.

Common hooks:

useState

useEffect

useMemo

useCallback

useRef

14. Controlled vs Uncontrolled Components
Controlled	Uncontrolled
React manages state	DOM manages state
Uses useState	Uses useRef
Predictable	Less predictable
15. What is Prop Drilling? How to Avoid It?

Answer:
Prop drilling is passing props through multiple intermediate components.

‚úÖ Avoid using:

Context API

Redux / Redux Toolkit

16. How Does React.memo Work?

Answer:
React.memo prevents unnecessary re-rendering of a component if props don‚Äôt change.

export default React.memo(MyComponent);


‚úÖ Works only for functional components

17. Difference Between useMemo and useCallback
useMemo	useCallback
Memoizes values	Memoizes functions
Optimizes heavy computation	Optimizes callback re-creation
18. Why is key Important in Lists?

Answer:

Helps React track list items

Improves reconciliation

Prevents UI bugs

‚ùå Without key ‚Üí Bad rendering & performance issues

19. Difference Between <a> Tag and <Link> in React
<a>	<Link>
Page reloads	No reload
Server navigation	Client-side navigation
Breaks SPA	Maintains SPA
‚úÖ LOGICAL CODING QUESTIONS (Extracted)
20. Reverse a String Using reverse()
str.split('').reverse().join('');

21. Reverse a String Without reverse()
function reverseStr(str) {
  let res = "";
  for (let i = str.length - 1; i >= 0; i--) {
    res += str[i];
  }
  return res;
}

22. Find Second Largest Number in Array
const arr = [10, 4, 25, 7];
arr.sort((a,b) => b - a);
console.log(arr[1]);

23. Remove Duplicates from an Array
const unique = [...new Set(arr)];


Or without Set:

const result = [];
for (let n of arr) {
  if (!result.includes(n)) result.push(n);
}

24. What is Debouncing?

Answer:
Debouncing delays function execution until the user stops triggering events for a specific time.

‚úÖ Used in:

Search input

API calls

Resize events

25. Basic Debounce Function
function debounce(fn, delay) {
  let timer;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

26. Can Debouncing Work Without setTimeout?

‚ùå No ‚Äî setTimeout is required to control the delay.




















1. COUNTER WITH FUNCTIONAL UPDATE (Basic State Interview Question)
import React, { useState } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>Count: {count}</h2>

      <button onClick={() => setCount(prev => prev + 1)}>+</button>
      <button onClick={() => setCount(prev => prev - 1)}>-</button>
    </div>
  );
};

export default Counter;


üëâ Tests:

State update

Functional update

Re-render understanding

‚úÖ 2. API CALL WITH AXIOS + LOADER + ERROR
import React, { useEffect, useState } from "react";
import axios from "axios";

const AxiosAPI = () => {
  const [users, setUsers] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  useEffect(() => {
    setLoading(true);
    axios
      .get("https://jsonplaceholder.typicode.com/users")
      .then(res => setUsers(res.data))
      .catch(() => setError("API Failed"))
      .finally(() => setLoading(false));
  }, []);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>{error}</p>;

  return (
    <ul>
      {users.map(u => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
};

export default AxiosAPI;

‚úÖ 3. FETCH + PROMISE API CALL
useEffect(() => {
  fetch("https://jsonplaceholder.typicode.com/posts")
    .then(res => res.json())
    .then(data => console.log(data))
    .catch(err => console.log(err));
}, []);

‚úÖ 4. DEBOUNCED SEARCH (MOST COMMON INTERVIEW QUESTION)
import React, { useState, useEffect } from "react";

const DebounceSearch = () => {
  const [text, setText] = useState("");
  const [query, setQuery] = useState("");

  useEffect(() => {
    const timer = setTimeout(() => {
      setQuery(text);
      console.log("API Call:", text);
    }, 500);

    return () => clearTimeout(timer);
  }, [text]);

  return (
    <input
      value={text}
      onChange={e => setText(e.target.value)}
      placeholder="Search..."
    />
  );
};

export default DebounceSearch;

‚úÖ 5. FILTER LIST WITH useMemo (PERFORMANCE QUESTION)
import React, { useMemo, useState } from "react";

const names = ["Apple", "Mango", "Banana", "Orange"];

const FilterList = () => {
  const [search, setSearch] = useState("");

  const filtered = useMemo(() => {
    return names.filter(n =>
      n.toLowerCase().includes(search.toLowerCase())
    );
  }, [search]);

  return (
    <>
      <input onChange={e => setSearch(e.target.value)} />
      <ul>
        {filtered.map(n => (
          <li key={n}>{n}</li>
        ))}
      </ul>
    </>
  );
};

export default FilterList;

‚úÖ 6. CONTROLLED vs UNCONTROLLED INPUT
‚úÖ Controlled:
const Controlled = () => {
  const [name, setName] = useState("");

  return <input value={name} onChange={e => setName(e.target.value)} />;
};

‚úÖ Uncontrolled:
const Uncontrolled = () => {
  const inputRef = useRef<HTMLInputElement>(null);

  const submit = () => alert(inputRef.current?.value);

  return (
    <>
      <input ref={inputRef} />
      <button onClick={submit}>Submit</button>
    </>
  );
};

‚úÖ 7. PROTECTED ROUTE (AUTH INTERVIEW QUESTION)
import { Navigate } from "react-router-dom";

const ProtectedRoute = ({ isAuth, children }: any) => {
  if (!isAuth) return <Navigate to="/login" />;
  return children;
};

‚úÖ 8. PREVENT UNNECESSARY RE-RENDER (React.memo)
const Child = React.memo(({ value }: any) => {
  console.log("Rendered");
  return <p>{value}</p>;
});

‚úÖ 9. VIRTUALIZATION EXAMPLE (10,000 ROWS PERFORMANCE)
import { FixedSizeList as List } from "react-window";

const BigList = () => (
  <List height={400} itemCount={10000} itemSize={40} width={300}>
    {({ index, style }) => (
      <div style={style}>Row {index}</div>
    )}
  </List>
);

‚úÖ 10. REDUX TOOLKIT BASIC SETUP (MOST ASKED)
import { configureStore, createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment: state => { state.value++; }
  }
});

export const { increment } = counterSlice.actions;

export const store = configureStore({
  reducer: { counter: counterSlice.reducer }
});

‚úÖ 11. JWT TOKEN HANDLING (FRONT-END)
localStorage.setItem("token", response.data.accessToken);

axios.interceptors.request.use(config => {
  config.headers.Authorization = `Bearer ${localStorage.getItem("token")}`;
  return config;
});

‚úÖ 12. LAZY LOADING COMPONENT (OPTIMIZATION)
const LazyComp = React.lazy(() => import("./Profile"));

<Suspense fallback={<p>Loading...</p>}>
  <LazyComp />
</Suspense>

‚úÖ 13. ERROR BOUNDARY (GRACEFUL UI)
class ErrorBoundary extends React.Component<any, any> {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) return <h2>Something went wrong</h2>;
    return this.props.children;
  }
}

‚úÖ 14. USE CALLBACK INTERVIEW EXAMPLE
const handleClick = useCallback(() => {
  console.log("Clicked");
}, []);

‚úÖ 15. USE REDUCER INTERVIEW EXAMPLE
const reducer = (state: number, action: any) => {
  if (action.type === "INC") return state + 1;
  return state;
};

const [count, dispatch] = useReducer(reducer, 0);











