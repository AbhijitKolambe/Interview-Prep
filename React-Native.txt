


Detailed Answer: What is ‚Äòstate‚Äô in React Native and how it differs from ‚Äòprops‚Äô
üß© Definition:

In React Native, state is an object that holds mutable, local data that influences how a component
 renders.
Unlike props, which are received from a parent, state is owned and controlled by the component 
itself.

When the state changes, React Native automatically re-renders the component to reflect the 
updated data in the UI.

üîß Under the Hood (How State Works Internally)

When you use a React hook like useState or a class-based this.setState, React uses an internal mechanism called the Fiber Reconciliation Algorithm to track and schedule updates efficiently.

Let‚Äôs break it down step-by-step:

1. Initial Render Phase

When a component mounts:

const [count, setCount] = useState(0);


React Native stores this count value in an internal hook state cell associated with that component‚Äôs fiber node.

The component is rendered based on count = 0.

2. State Update

When you call:

setCount(count + 1);


React does not immediately change the variable.
Instead:

It queues a state update inside the fiber node.

It schedules the component to re-render in the next render cycle.

3. Reconciliation and Re-rendering

During the next render:

React compares the new virtual component tree (with updated state) to the previous one using the Reconciliation algorithm.

Only the parts of the UI that actually changed are re-rendered (not the whole app).

In React Native, these virtual updates are translated to native UI changes through the React Native bridge (or the new Fabric renderer, which is more direct).

4. Commit Phase

React commits the updated UI to the screen:

The new state is stored in the internal hook cell.

The old state is discarded.

The UI reflects the latest state.

‚öñÔ∏è Difference Between Props and State
Feature	Props	State
Definition	Data passed from parent to child.	Local data owned by the component.
Mutability	Immutable (read-only).	Mutable (can change with setState / useState).
Who Controls It?	Controlled by the parent component.	Controlled by the component itself.
Purpose	Used for data communication between components.	Used to store dynamic, changeable data.
Update Mechanism	Parent re-renders with new props.	Component updates itself using setState.
Re-render Trigger	When parent‚Äôs props change.	When state changes via React update queue.












Explain the React Native component lifecycle.
1. Mounting Phase

Component is created and added to the UI.
‚Üí Happens once when the component first appears.

 2. Updating Phase

Triggered when props or state change.
‚Üí Component re-renders to reflect the latest data.

 3. Unmounting Phase

Component is removed from the UI.
‚Üí Used to clean up resources like timers or listeners.








How would you debug a React Native application?
React Native provides tools like the in-app developer menu, logging using 'console.log', 
and integration with debugging tools like React DevTools or Flipper.
 You can also use Chrome Developer Tools for debugging by running your 
 app in debug mode and accessing it from a web browser. Native Debugging Use Android Studio or Xcode for native code issues.
‚Üí Helps trace crashes or native module problems.





What is StyleSheet in React Native and why is it used?

StyleSheet is a React Native module used to define and manage component styles in a structured and optimized way.

Instead of using inline styles directly in JSX, you can create a style object using StyleSheet.create().
This approach helps validate, organize, and optimize styles for better performance.

Example:
import { StyleSheet, View, Text } from 'react-native';

const App = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Hello React Native</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 20,
    color: '#333',
  },
});

Why use StyleSheet:

‚ö° Performance optimization:
Styles are preprocessed and referenced by ID instead of passing full objects every render.

‚úÖ Validation:
StyleSheet.create() warns you if you use invalid style properties.

üß© Maintainability:
Keeps styles organized and reusable across components.

üß† Consistency:
Encourages a single source of truth for component styling.





How do you handle navigation between screens in React Native?

In React Native, navigation between screens is commonly handled using React Navigation, which is a popular and flexible library for managing screen transitions and routing.

Steps:

Install React Navigation and dependencies

npm install @react-navigation/native
npm install @react-navigation/native-stack
npx expo install react-native-screens react-native-safe-area-context


Set up a Navigation Container

import * as React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import HomeScreen from './HomeScreen';
import DetailsScreen from './DetailsScreen';

const Stack = createNativeStackNavigator();

export default function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator initialRouteName="Home">
        <Stack.Screen name="Home" component={HomeScreen} />
        <Stack.Screen name="Details" component={DetailsScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}


Navigate between screens

// Inside HomeScreen.js
const HomeScreen = ({ navigation }) => {
  return (
    <Button
      title="Go to Details"
      onPress={() => navigation.navigate('Details')}
    />
  );
};

Common navigation methods:
Method	Description
navigate('ScreenName')	Go to a screen (doesn‚Äôt add duplicate if already on stack)
push('ScreenName')	Always adds a new instance of the screen
goBack()	Go to the previous screen
replace('ScreenName')	Replace the current screen
reset()	Reset the navigation state
Types of Navigators in React Navigation:

Stack Navigator ‚Üí Standard push/pop screen transitions

Tab Navigator ‚Üí Bottom or top tab navigation

Drawer Navigator ‚Üí Side menu navigation

Material Navigator ‚Üí Material Design‚Äìstyle transitions







What is Flexbox and its role in React Native layout?

Flexbox (Flexible Box Layout) is a layout system used in React Native to design responsive and adaptive user interfaces.
It helps in aligning, distributing, and sizing components within a container ‚Äî even when their size is dynamic or unknown.

React Native uses Flexbox as its primary layout system, just like CSS, but with a few property name differences and some defaults optimized for mobile.

Key Properties of Flexbox:
Property	Description
flexDirection	Defines the main axis ‚Äî row (horizontal) or column (vertical, default).
justifyContent	Aligns children along the main axis (flex-start, center, space-between, etc.).
alignItems	Aligns children along the cross axis (flex-start, center, stretch, etc.).
flex	Defines how much space an item should take relative to others.
alignSelf	Overrides alignItems for individual items.
flexWrap	Allows items to wrap to the next line if space is insufficient.
Example:
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const FlexExample = () => {
  return (
    <View style={styles.container}>
      <View style={styles.box1}><Text>Box 1</Text></View>
      <View style={styles.box2}><Text>Box 2</Text></View>
      <View style={styles.box3}><Text>Box 3</Text></View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row', // Layout items horizontally
    justifyContent: 'space-around', // Distribute space evenly
    alignItems: 'center', // Align items vertically in center
  },
  box1: { backgroundColor: 'skyblue', padding: 20 },
  box2: { backgroundColor: 'orange', padding: 20 },
  box3: { backgroundColor: 'lightgreen', padding: 20 },
});

export default FlexExample;

Why Flexbox is important in React Native:

üì± Responsive layouts: Adjusts automatically to various screen sizes and orientations.

üß© Simplified design: Reduces the need for manual positioning or fixed dimensions.

‚ö° Cross-platform consistency: Works the same on Android, iOS, and web.






14. What are 'keys' in React Native and why are they important in lists?

Keys are unique identifiers assigned to elements in a list.
They help React Native track which items have changed, been added, or removed, allowing it to efficiently re-render only the necessary components.
Without keys, React may re-render the entire list unnecessarily, leading to performance issues or incorrect UI updates.

‚úÖ Example:

{data.map(item => <Text key={item.id}>{item.name}</Text>)}

15. How can you make a network request in React Native?

You can make network requests using:

The fetch API (built-in)

Or third-party libraries like Axios

These allow you to fetch data from APIs asynchronously using Promises or async/await syntax.

‚úÖ Example:

const fetchData = async () => {
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();
  console.log(data);
};

16. Describe the purpose of 'AsyncStorage' in React Native.

AsyncStorage provides persistent, asynchronous, key-value storage on the device.
It‚Äôs typically used for storing user preferences, auth tokens, or small bits of app data locally.

‚ö†Ô∏è Note: AsyncStorage has been moved to the community package:

npm install @react-native-async-storage/async-storage


‚úÖ Example:

await AsyncStorage.setItem('userToken', token);
const value = await AsyncStorage.getItem('userToken');

17. How can you integrate Redux with a React Native app?

Redux is integrated by:

Creating a store to hold global state.

Wrapping your app in a <Provider> from react-redux.

Defining reducers and actions to manage state changes.

Connecting components using useSelector and useDispatch.

‚úÖ Example:

import { Provider } from 'react-redux';
import { store } from './store';

export default function App() {
  return (
    <Provider store={store}>
      <RootNavigator />
    </Provider>
  );
}

18. How do you optimize performance in a React Native application?

Performance optimization involves:

Using React.memo / PureComponent to prevent unnecessary re-renders

Using FlatList instead of ScrollView for large lists

Optimizing images with caching

Avoiding anonymous functions and inline styles inside render

Profiling with Flipper or React DevTools

Reducing JS thread work and using native modules for heavy tasks

19. Explain the concept of 'HOC' (Higher-Order Component) in React Native.

A Higher-Order Component (HOC) is a function that takes a component and returns an enhanced component with additional functionality.
It‚Äôs used to reuse logic such as authentication checks, data fetching, or logging.

‚úÖ Example:

function withLogger(WrappedComponent) {
  return (props) => {
    console.log('Rendered:', WrappedComponent.name);
    return <WrappedComponent {...props} />;
  };
}

20. How can you integrate third-party libraries in a React Native app?

You can integrate libraries using npm or yarn:

npm install library-name


Then import and use them in your components.
For libraries with native code, link them automatically with:

npx pod-install


(For older RN versions, react-native link was used.)

21. What are 'Touchable' components in React Native and how do they work?

Touchable components provide press and gesture interaction for UI elements.
Common types include:

TouchableOpacity

TouchableHighlight

TouchableWithoutFeedback

Pressable (modern and more flexible)

They detect user touches (onPress, onLongPress) and provide visual feedback like opacity changes.

‚úÖ Example:

<TouchableOpacity onPress={() => alert('Pressed!')}>
  <Text>Click Me</Text>
</TouchableOpacity>

22. How do you handle form validation in React Native?

You can validate forms by managing input values in state, checking them on submission, and showing error messages.
You can also use libraries like Formik, Yup, or react-hook-form for robust validation.

‚úÖ Example (basic):

if (!email.includes('@')) {
  setError('Enter a valid email address');
}

23. Explain the architecture of a React Native app.

A React Native app follows a component-based architecture, consisting of:

UI Components ‚Äì reusable building blocks

State & Props ‚Äì data flow management

Business Logic ‚Äì using Context API or Redux

Navigation ‚Äì handled by React Navigation

Bridge ‚Äì connects JavaScript with native Android/iOS modules

üß© JS Code ‚Üí Bridge ‚Üí Native Platform ‚Üí UI

24. What is the role of 'navigator' in React Navigation?

A navigator is a component that defines the navigation structure of your app.
It manages screen transitions, the navigation stack, and history.

Types of navigators:

StackNavigator

TabNavigator

DrawerNavigator

‚úÖ Example:

const Stack = createNativeStackNavigator();
<Stack.Navigator>
  <Stack.Screen name="Home" component={HomeScreen} />
</Stack.Navigator>

25. How do you handle platform-specific code in React Native?

You can handle platform-specific behavior in two ways:

Using the Platform API:

import { Platform } from 'react-native';

const styles = StyleSheet.create({
  text: {
    color: Platform.OS === 'ios' ? 'blue' : 'green',
  },
});


Platform-specific files:

Component.ios.js

Component.android.js